<!DOCTYPE html>

<html lang="en-US" prefix="og: http://opg.me/ns#">
  <head>
    <meta charset="UTF-8" />

    <meta name="title" property="og:title" content="Satellite" />

    <meta
      name="description"
      property="og:description"
      content="Satellite is an open-source GraphQL Backend-as-a-Service that makes it easy to get a GraphQL API up and running to power the frontend of your dynamic web application."
    />

    <meta name="type" property="og:type" content="website" />

    <meta
      name="url"
      property="og:url"
      content="https://satellite-baas.github.io/"
    />

    <meta
      name="image"
      property="og:image"
      content="images/logos/satellite-full.png"
    />

    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta name="author" content="Will Baker, Ilyas Kussainov, Jordan Moore, Lewis Reynolds" />

    <title>Satellite</title>

    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="/images/icons/favicons/apple-touch-icon.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="/images/icons/favicons/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="/images/icons/favicons/favicon-16x16.png"
    />
    <link rel="manifest" href="/images/icons/favicons/site.webmanifest" />
    <link
      rel="mask-icon"
      href="/images/icons/favicons/safari-pinned-tab.svg"
      color="#5366f5"
    />

    <link rel="shortcut icon" href="/images/icons/favicons/favicon.ico" />
    <meta name="msapplication-TileColor" content="#da532c" />
    <meta
      name="msapplication-config"
      content="/images/icons/favicons/browserconfig.xml"
    />
    <meta name="theme-color" content="#ffffff" />

    <!-- <style>reset</style> -->

    <link rel="stylesheet" href="stylesheets/reset.css" />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/gruvbox-dark.min.css"
      charset="utf-8"
    />

    <!-- <style></style> -->

    <link rel="stylesheet" href="stylesheets/main.css" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

    <!-- <script></script> -->

    <script src="javascripts/application.js"></script>

    <style></style>
  </head>

  <body>
    <div class="logo-links">
      <p id="river-logo">MENU</p>

      <a href="https://github.com/satellite-baas" target="_blank">
        <img
          src="images/logos/github-black.png"
          alt="github logo"
          id="github-logo"
        />
      </a>
    </div>
    <a id="toTop-link" href="#" target="_blank">
      <img
        src="images/logos/back-to-top.png"
        alt="Back to top"
        id="toTop-logo"
      />
    </a>
    <nav id="site-navigation">
      <ul>
        <li>
          <a href="#home" id="home-link">HOME</a>
        </li>

        <li>
          <a href="#case-study" id="case-study-link">CASE STUDY</a>

          <nav id="case-study-mobile">
            <ul></ul>
          </nav>
        </li>

        <li>
          <a href="#our-team" id="our-team-link">OUR TEAM</a>
        </li>
      </ul>
    </nav>

    <header id="home">
      <h1>
        <img id="hero-logo" src="images/logos/satellite-hero.png" alt="Satellite logo" />
        <p>A GraphQL Backend-as-a-Service for dynamic web applications</p>
      </h1>
    </header>

    <section class="integration">
      <article class="box">
        <div class="text-box">
          <h1>Something about how easy it is to deploy!</h1>
        </div>
      </article>

      <div class="box">
        <img
          id="rocket-logo"
          src="images/logos/768px-rocket.png"
          alt="A launching rocket logo"
        />
      </div>
    </section>

    <section class="integration">
      <div class="box">
        <img
          id="banner-deploy"
          src="images/diagrams/first-banner.png"
          alt="Satellite UI"
        />
      </div>

      <article class="box">
        <div class="text-box">
          <h1>
            Something about how easy it is to use!
          </h1>
        </div>
      </article>
    </section>

    <section class="integration">
      <article class="box">
        <div class="text-box">
          <h1>
            And viola!  Look at this cool app you can make.
          </h1>
        </div>
      </article>

      <div class="box">
        <img
          id="banner-deploy"
          src="images/diagrams/first-banner.png"
          alt="Satellite UI"
        />
      </div>
    </section>



    <main>
      <section id="case-study">
        <h1>Case Study</h1>

        <div id="side-nav">
          <img src="images/logos/satellite-mark.png" alt="Satellite logo" />
        </div>

        <nav>
          <ul></ul>
        </nav>

        <h2 id="what-is-satellite">1) What is Satellite?</h2>

          <p>
            Satellite is an open-source GraphQL Backed-as-a-Service (BaaS) that enables teams to easily deploy and manage GraphQL backends for web applications.
          </p>

          <p>
            Satellite abstracts away the complexity of setting up the infrastructure for a backend and the unique challenges of configuring a GraphQL server. It allows the application developer to define their entire backend using only a GraphQL schema. And with its multi-tenant architecture based on Kubernetes, Satellite allows developers to create and use as many backends as they need. Satellite is a great fit for new applications, where ease of use and speed of deployment is the top priority.
          </p>

          <p>
            In this case study, we describe how we designed and built Satellite, the specific tradeoffs we made, and some of the technical challenges we encountered. In order to fully understand Satellite's design, first we'll discuss the general architecture of a modern web application - and one specifc application that drove the development of GraphQL.
          </p>

        <h2 id="web-app-architecture">2) Web App Architecture</h2>

        <h3 id="frontend-vs-backend">2.1) Frontend vs Backend</h3>

        <p>
          Web applications can be thought of has having two parts - the frontend and the backend. The frontend is responsible for the application's appearance and handling user interactions with the application. To put it simply, the frontend is what the user sees when using the application. On the other side of an application is the backend, which provides the business logic and persistent data handling operations needed to power the frontend.
        </p>

        <p>
          [diagram]
        </p>

        <h3 id="api-s-in-web-applications">2.2) How do the Frontend and Backend Communicate?</h3>

        <p>
          In modern applications, a common practice is to completely separate the frontend from the backend. Applications using this kind of architecture require some way for the frontend and backend to communicate. This communication is done through something called an API. The backend produces the API that the frontend consumes. This kind of architecture allows frontend and backend teams to work independently, and facilitates development of different frontend client applications using the same backend.
        </p>
 
        <p>
          [diagram]
        </p>

        <h3 id="facebook-s-news-feed-api">2.3) Designing a Better API: Facebook's News Feed</h3>

        <p>
          One recent innovation in API development occurred at Facebook with their news feed API.
        </p>

        <p>
          In 2011 Facebook decided to completely re-write their native iOS app, and immediately hit issues when trying to re-use the existing API for their News Feed feature.
        </p>

        <h4>2.3.1) Why the Existing API Didn't Work</h4>

        <p>
          This was the first time they had tried to develop an application like this - where the backend was responsible for just returning data, and the front-end was responsible for all of the user interaction. And for Facebook’s News Feed, it isn’t as simple as retrieving a story and all of the information for that particular story. Each story is interconnected, nested, and recursive. The existing APIs weren’t designed to allow developers to expose a rich, news feed-like experience on mobile. They didn’t have a hierarchical nature, or let developers select the exact data they needed. They were, in fact, designed to return HTML back to a web browser.
        </p>
        
        <p>
          What this meant was that the client application would need to make several round-trips to the API to get the information it wanted. For example, it might have to first get one story, and from that story figure out what other stories it needed to request to complete the feed, and keep repeating that process over and over until it got all the information it needed. Not only did this result in a large amount of round-trips, but each response would contain a lot of data that wasn’t needed. Both of these factors combined resulted in unacceptable network performance for the new app.
        </p>

        <p>
          [diagram]
        </p>

        <h4>2.3.2) Why Facebook Created GraphQL</h4>
        
        <p>
          At this point, it was clear to Facebook that they needed to design a better API for the News Feed feature to improve the mobile experience. Nick Schrock, one of the co-creators of this new API which we now know of as GraphQL, had this to say about their design philosophy:
        </p>

        <blockquote>
          "We tried to design what we thought was the ideal API for front-end developers, and then work backwards to the technology."
          <br>
          - Nick Schrock, GraphQL co-creator
        </blockquote>

        <p>
          The key feature of GraphQL  is that it allows the front-end client to specify exactly the information it needs for a given request - eliminating the issues of over-fetching and preventing the need for multiple round trips. This networking performance improvement was critical for mobile applications, which have limited bandwidth and require fast response times.
        </p>

        <p>
          [diagram]
        </p>

        <p>
          One other important aspect of GraphQL that has lead to the multitude of client-side tools available is that a GraphQL API uses a strongly typed system to describe its capabilities. This allows clients to use a process called introspection to see exactly what they are able to do with the API, making GraphQL effectively self-documenting.
        </p>

        <h4>2.3.3) Widespread Adoption of GraphQL</h4>

        <p>
          GraphQL was initially developed by Facebook to solve a very specific problem - rebuilding their newsfeed API. Used as an internal tool by Facebook from 2012 until 2015, it ended up spreading and covering most of their mobile application due to its strengths. An open-source version of GraphQL was released in 2015. Soon after it was open-sourced, GraphQL began being used by many other companies like AirBNB, Twitter, Netflix, and Github, and has continued to grow in adoption ever since.
        </p>
        
        <h2 id="what-is-graphql">3) What is GraphQL?</h2>

        <p>
          At a very high level, GraphQL is referred to as a “query language for APIs”. While this general term is helpful for placing where GraphQL fits as a tool for developing web applications, a more specific definition is necessary to get an idea of what kinds of things a developer will have to deal with when building a GraphQL application.
        </p>

        <h3 id="the-graphql-specification">3.1) The GraphQL Specification</h3>

        <p>
          GraphQL is actually a specification that describes its type system and query language [cite: http://spec.graphql.org/draft/]. Both of these will be covered in more detail layer on, but for now keep in mind that this specification can be implemented in any programming language - its not specific to any one particular application or architecture. There are, in fact, service-side implementations of the GraphQL specification in just about any programming language you might be interested in [cite: https://graphql.org/code/]. These server-side software implementations are known as GraphQL servers.
        </p>

        <h3 id="graphql-servers">3.2) GraphQL Servers</h3>

        <p>
          GraphQL servers communicate with clients using the standard HTTP protocol [cite: https://graphql.org/code/]. The GraphQL server is responsible for parsing the request into an abstract syntax tree so that the request can be traversed programmatically. The GraphQL server then walks this tree and determines how to respond to the request. Once the GraphQL server has assembled the request, it is returned to the client as a JSON object - once again over standard HTTP.
        </p>

        <h3 id="interacting-with-a-graphql-api">3.3) Interacting with a GraphQL API</h3>

        <p>
          The overall sequence of a GraphQL API interaction is made possible by this implementation of the type system on the server, and the use of the query language by both the client and server. The data available on the server is described using the type system, which allows clients to ask for exactly the information they want, which then leads to the client getting exactly that information in response.
        </p>

        <p>
          [diagram]
        </p>
        
        <h2 id="graphql-backends">4) GraphQL Backends</h2>
        <p>
          Now that we have an understanding of how the frontend and backend communicate in a modern web application, the kind of problem that Facebook created GraphQL to solve, and a general idea of how GraphQL works, you might be interested in creating your next application using a GraphQL API. While GraphQL certainly has its place in enabling frontend development, there’s a lot to consider when it comes to building the backend of an application in general, and a GraphQL application in particular.
        </p>

        <h3 id="backend-architecture">4.1) Backend Architecture</h3>

        <p>
          First, let's take a look at the general setup for a backend:
        </p>

        <p>
          [diagram]
        </p>
        
        <p>
          Typically, a backend is built with a 3-tier architecture. The different "tiers" in this kind of architecture serve the following purposes:
        </p>

        <p>
          <b>Web Server</b>: The web server acts as the internet-facing entry point to the backend. Web servers are highly optimized to handle requests involving <em>static</em> data - such as static file serving and caching - and can typically handle very large volumes of requests for this kind of data [some kind of citation here]. For requests that the web server cannot fulfill directly, the web server acts as a reverse-proxy, forwarding requests to the rest of the backend.
        </p>

        <p>
          <b>Application Server</b>: The application server is where requests for <em>dynamic</em> data end up, and it is responsible for processing and fulfilling those requests. The application server is where the business logic that powers the application resides, and this logic is responsible for determining what information to send back in response. Because application servers have no way of persisting data, they will need to access some kind of underlying data store for requests that need access to this persistent data.
        </p>

        <p>
          <b>Database</b>: The database satisfies the need for an application to have some way to persist the long-lived data of the application. Interaction with an application's database is handled through the application server, as described above.
        </p>

        <h3 id="backend-features">4.2) Backend Features</h3>
        <p>
          Now that we understand what kind of architecture a backend requires, we can start to imagine all of the different things that a backend might need to do. There’s a wide range of different tasks an application might need its backend to perform, all of which require configuration and programming to enable.
        </p>

        <p>
          [diagram]
        </p>
        
        <p>
          For the backend of a GraphQL application, one of the key features is actually producing the GraphQL API.
        </p>

        <h3 id="what-are-the-challenges-of-a-graphql-api">4.3) What are the Challenges of a GraphQL API?</h3>

        <p>
          In addition to the complex architecture of a backend, the challenges associated with producing a GraphQL API are frequently mentioned by both individual developers, and described by companies who have went down the path of adopting GraphQL in their production applications.
        </p>

        <p>
          Arnaud Luaret, author of the book "The Design of Web APIs", mentions the new challenges that a GraphQL API brings [citation]:
        </p>

        <blockquote>
          “GraphQL does not ease an API provider’s job and brings new challenges”
          <br>
          - Arnaud Lauret, author of The Design of Web APIs
        </blockquote>
        
        <p>
          In PayPal's Engineering Blog Article "Scaling GraphQL at Paypal", a similar challenge is mentioned - GraphQL is different than what develops may be used to [citation]:
        </p>

        <blockquote>
          “Ensure that architects and API designers are on board with GraphQL ... More than likely, they have designed REST APIs for years. GraphQL is different.”
          <br>
          -Scaling GraphQL at Paypal - Paypal Engineering Blog
        </blockquote>

        <h3 id="how-is-a-graphql-api-produced">4.4) How is a GraphQL API Produced?</h3>

        <p>
          To produce a GraphQL API, we need to run a piece of software called a GraphQL server. As we mentioned earlier, A GraphQL server is a specialized software package that can receive and respond to GraphQL requests. The behavior of a GraphQL server is defined using two inputs: A GraphQL schema, and Resolver functions. At a high level, the GraphQL schema defines “what” the GraphQL server can do using the GraphQL type system, and the resolver functions tell it how to do it.
        </p>

        <p>
          A detailed look at a GraphQL server is shown here, where the GraphQL API is defined using a GraphQL schema, and the API invokes the necessary resolver functions to carry out the actions needed to produce the response, such as querying a database: 
          </p>

        <p>
          [diagram]
        </p>

        <p>
          Next, we'll take a look at the GraphQL schema and resolver functions in a little more detail, to better appreciate what goes into creating them.
        </p>

        <h4>4.4.1) GraphQL Schema</h4>

        <p>
          The GraphQL schema defines the functionality available to client applications that connect to the GraphQL server. The schema is made up of types, which have one or more fields.
        </p>

        <p>
          A basic GraphQL schema is shown here.  It has several types - the “Person” type is an object type.  Object types make up the “things” of your API - you could think of them as entities, or objects.  Each type will also have fields - for the Person here, there is a name and phone field, which are a string and integer. You can think of fields like the properties of your objects.
        </p>

        <p>
          [diagram]
        </p>

        <p>
          There are actually many more types than just object types.  Two very important ones are the query and mutation types.  These describe what actions you should be able to do with your object types.  Queries are all about simply retrieving data, while mutations involve some kind of change to the data. Here we have a query to find a person by name, and a mutation to create a new person.
        </p>

        <p>
          Keep in mind that these definitions of queries and mutations don’t say anything about *how* the API gets the job done - it's only describing what the API should be able to do!
        </p>

        <h4>4.4.2) GraphQL Resolvers</h4>

        <p>
          Resolvers are functions that allow the GraphQL server to know how to respond to requests.
        </p>

        <p>
          Unlike the GraphQL schema, which has to comply with the requirements of the GraphQL specification, GraphQL resolvers are flexible.  They are just functions, and you can do anything with them that you would do with any other function.  The only requirement is that the function needs to return a value which corresponds to the field specified by the schema.
        </p>

        <p>
          As shown in this example, resolvers correspond to the respective query and mutation types that were defined in the GraphQL schema.
        </p>

        <p>
          [diagram]
        </p>

        <h3 id="how-can-we-reduce-the-complexity-of-a-graphql-backend">4.5) How Can we Reduce the Complexity of a GraphQL Backend?</h3>

        <p>
          We can now see the big picture of everything that goes into creating a GraphQL backend. In addition to all of the architecture and configuration required for for a standard backend, we also have the inputs needed to produce the GraphQL API - the schema and resolver functions.
        </p>

        <p>
          [diagram]
        </p>

        <p>
          For a front end developer trying to get a GraphQL application up and running quickly, that’s a lot to think about. Because of this, we wondered if there might be a way to make it easier for front-end developers to get a relatively straightforward GraphQL backend up and running quickly.
        </p>

        <p>
          Ideally, the developer wouldn’t have to think about things like the architecture of the backend, the configuration for standard backend features, or even the lower-level GraphQL configuration like defining resolver functions.
        </p>

        <p>
          As we searched for an answer, we found a promising potential solution - something called a Backend-as-a-Service. Basically, a backend as a service provides an abstraction over all of the functionality and complexity of the backend, which seemed like good answer to the question of how we could make it easier to get a GraphQL backend up and running quickly.
        </p>

        <p>
          Next, we'll take a look at exactly what a Backend-as-a-service is, and what we found when we evaluated the existing options.
        </p>

        <h2 id="backend-as-a-service">5) Backend-as-a-Service</h2>
       
        <h3 id="what-is-a-backend-as-a-service-baas">5.1) What is a Backend-as-a-Service (BaaS)?</h3>

        <p>
          A backend-as-a-service encapsulates all of the underlying architecture that a backend needs - the web server, app server, and database - and also provides the essential functionality of a backend pre-configured such as SSL certificates, front-end hosting, and data persistence. The functionality of the backend is made available to frontend applications through an API.
        </p>

        <p>
          [diagram]
        </p>

        <p>
          With a backend as a service, you can simply ask for a backend to be created, and get and endpoint to access all of that backend's functionality.
        </p>

        <h3 id="why-use-a-baas">5.2) Why Use a BaaS?</h3>

        <p>
          Why would somebody use a BaaS? As we&rsquo;ve seen, a backend as a service facilitates frontend development, abstracting away the complexity of the backend, allowing for faster application development.
        </p>

        <p>
          This abstraction comes at a cost though. For one, the BaaS itself still requires setup and maintenance. Also, with these kinds of services, as you gain more abstraction you have to sacrifice control.
        </p>

        <p>
          [diagram]
        </p>

        <p>
          The lowest level of abstraction is provided by something called an <b>Infrastructure-as-a-Service</b>. With this option, the developer is responsible for configuring everything from the operating system and up, making it very low on abstraction, but high on control.
        </p>

        <p>
          A <b>Platform-as-a-Service</b> provides more abstraction than an infrastructure as a service, but less than a BaaS. With a platform as a service, the developer has to provide all of the application code for the backend, but the platform handles operating system configuration and deployment.
        </p>

        <p>
          Finally, with a <b>Backend-as-a-Service</b>, we are the highest level of abstraction. The developer no longer needs to provide any backend code or handle any backend configuration. But along with that high amount of abstraction, they aren't able to control much if anything about how the BaaS works internally.
        </p>


        <h3 id="existing-graphql-baas">5.3) Existing GraphQL BaaS</h3>

        <p>
          With all of the benefits that a BaaS offers for front-end development, it is no surprise that there are several existing options to chose from for a GraphQL BaaS. Broadly speaking, these existing options can be grouped into two categories: Manage services, and open-source solutions.
        </p>

        <h4>5.3.1) Managed Services</h4>
        
        <p>
          There are a number of managed services available for a GraphQL BaaS.  These are paid, proprietary services and are fully supported by the provider. Using these paid services completely abstracts away the complexity of setting up and managing the backend of your application. In general, they are easy to use - with some caveats.  AWS Amplify, for example, has a tight integration with other AWS services [citation], making it a great option if you are fully committed to using AWS services for your entire application - although it is more difficult to use for non-AWS services. And since there is no need to deploy anything to use these managed services, there is zero complexity involved in their deployment.
        </p>
        
        <p>
          These managed services also tend to have a large amount of features, with services like 8Base [citation] and Nhost [citation] providing just about any feature you could ever want from your backend even beyond the GraphQL API. Slash GraphQL [citation] has comparatively fewer features, but still has a number of advanced options such as the ability to run custom logic via serverless lambda functions.
        </p>
        
        <h4>5.3.2) Open-Source Solutions</h4>
        
        <p>
          For open-source options, probably the most popular is the Parse platform [citation]. Parse is a self-hosted platform that provides a backend with all of the features you could need for your application - including a GraphQL API. Unlike the managed services, you can host Parse anywhere you want, and you have full control over your data and infrastructure. 
        </p>
        
        <p>
          Another, less well-known GraphQL backend-as-a-service is Spacecloud [citation]. Spacecloud offers a similar wide range of features as the Parse platform and also lets you self-host it wherever you want.
        </p>

        <h3 id="why-not-use-an-existing-graphql-baas">5.4) Why Not Use an Existing GraphQL BaaS?</h3>
        
        <p>
          The existing GraphQL backend-as-a-service options definitely have a lot of positive features, but they naturally have their own set of tradeoffs as well.
        </p>

        <p>
          Although managed services don’t require any effort to deploy and are generally easy to use, they are obviously not fully open source. With these services, you don’t have any control over how your application and its data is hosted, and you run the risk of vendor lock-in if your application ever outgrows the BaaS.
        </p>

        <p>
          With the existing open source options, you get to maintain control of your data, but have to deal with more complicated deployment and usage. You will need to worry about things like selecting and configuring a database with both Parse and Spacecloud, for example. And with their wide range of features and options, it can take quite a bit of time to get started with the existing open source options once they are deployed.
        </p>

        <h3 id="where-does-satellite-fit">5.4) Where Does Satellite Fit?</h3>

        <p>
          After reviewing the existing BaaS options, we saw that there was an opportunity for an easy to deploy and use, self-hosted GraphQL backend as a service. We were inspired by the ease of use of managed services, and the ability to self-host the open-source solutions and maintain full control of your application.
        </p>

        <p>
          [diagram]
        </p>

        <p>
          We can see here where Satellite fits compared to existing open-source platforms like Parse and Spacecloud, as well as compared to the various managed GraphQL BaaS services.
        </p>

        <p>
          Compared to the other GraphQL BaaS options that are available, we chose to build Satellite with fewer features in order to keep it easy use.  We wanted to keep Satellite lean in order to minimize complexity of deployment, and make the essential features of a GraphQL backend intuitive to use. Like other existing open-source options, Satellite is entirely open source, and you can host it anywhere you’d like.
        </p>

        <p>
          Since Satellite doesn’t have a huge amount of features, it isn’t going to be a perfect fit for every application. If your application needs a fully supported, one-stop-shop for all the features that a backend could provide in one place, Satellite isn’t going to be a great solution for you. But for developers who need an open-source solution to quickly get a GraphQL backend running with only the essential features needed to support their web application, Satellite might be a viable option to consider.
        </p>

        <p>
          In the next section, we will describe how we designed Satellite - including the challenges we faced, and the decisions we made to overcome those challenges.
        </p>

        <h2 id="the-core-application">6) The Core Application</h2>

        <p>
          The Satellite core application represents a single instance of a backend. It provides client applications a GraphQL API for accessing the underlying data store, and static file serving for front-end hosting.
        </p>

        <p>
          [diagram]
        </p>

        <p>
          These features are made possible using several components under the hood. An nginx webserver is used for serving static files and routing incoming requests, a NodeJS express application server provides a way for administrative actions to be made on the Satellite instance, and a Dgraph Graph Database is used as the data store.
        </p>

        <p>
          Our top priority in designing Satellite was to keep it easy to use. In this rest of this section, we will explain the most significant challenges we had to overcome in order to achieve that goal, and how their solutions resulted in this architecture.
        </p>

        <h3 id="how-is-an-application-s-data-defined">6.1) How is an Application's Data Defined?</h3>
        
        <p>
          When we started building Satellite, we were immediately faced with a question - How do we build a GraphQL backend that works for any application, without knowing what kind of data that application will require ahead of time? Essentially, we needed to build a “generic” GraphQL backend that would work for any application.
        </p>

        <p>
          To answer that question, first we had to determine the best way to allow a developer to define the structure of their application's data.
        </p>

        <h4>6.1.1) GraphQL Schema vs. Database Schema</h4>

        <p>
          Typically, the backend for a GraphQL application will require some kind of persistent data store. A common database that is good for storing the kind of inter-related data that a GraphQL application will likely use is a relational database. A relational database requires a schema of its own to define how it will store the data - in addition to the GraphQL schema required to define the API.
        </p>

        <p>
          Requiring an additional database schema in addition to the GraphQL schema adds another piece of configuration that must be provided to the backend - something we wanted to minimize in order to keep Satellite easy to use.
        </p>

        <h4>6.1.2) A Hypothetical Database Schema Generator</h4>

        <p>
          To prevent the need for an additional schema definition in order to use Satellite, at this point we thought we could come up with a way to generate a relational database schema from a GraphQL schema.  This would eliminate the need for two schemas, and make it possible to define the backend’s data using only a GraphQL schema.
        </p>

        <p>
          But what would this look like? Would it even be possible? 
        </p>

        [diagram]

        <p>
          Taking a very simple GraphQL schema consisting of only a single object type like we see here, it's easy enough to see how this would work. For a GraphQL schema with a single object type with a few fields, we could generate a database schema defining a table corresponding to the object, with all of the necessary columns to represent the fields of the object.
        </p>

        <p>
          The logic for this hypothetical conversion process should be a relatively straight-forward matter of converting strings - so for now, we were ready to proceed to the next challenge.
        </p>

        <h3 id="how-is-an-application-s-data-accessed">6.2) How is an Application's Data Accessed?</h3>

        <p>
          Now that we had a way to define the data of an application, we needed a way to access the data.
        </p>

        <h4>6.2.1) Resolver Functions in a GraphQL BaaS</h4>
        
        <p>
          As we’ve mentioned, making the data available for a GraphQL backend requires a GraphQL server to serve the API, that that GraphQL server needs to contain resolver functions to know how to respond to requests. The thing is, writing these resolver functions requires the developer to go "under the hood" and edit the backend’s code - something we needed to avoid in order to keep Satellite easy to use.
        </p>

        <h4>6.2.2) A Hypothetical Resolver Function Generator</h4>
        
        <p>
          As a possible solution, at this point we thought we could take a similar approach as we had for converting the GraphQL schema to a database schema - we could try to automatically generate resolver functions for the most common actions you might want to take with your application’s data - creating, reading, updating, and deleting - and automatically initialize the GraphQL server with those generated functions.
        </p>

        <p>
          Once again, would it even be possible to do this? We again considered our very simple GraphQL schema to consider what this resolver function generator might look like:
        </p>

        <p>
          [diagram]
        </p>

        <p>
          We would need 4 resolvers for each object type in the schema - one for reading the data with a Query type, and 3 mutations for creating, updating, and deleting. This was starting to get significantly more complicated, but still seemed doable, since all of the resolvers followed a similar pattern, and we should be able to generate the correct function signatures and required databases actions to make it work - at least for a very simple schema like this. Our imagined schema converter would no longer be a matter of converting strings - now it would need to generate functions as well, but we still felt confident enough to proceed down this path.
        </p>

        <h4>6.2.3) The Hypothetical Architecture</h4>
        
        <p>
          We could now envision a hypothetical architecture for our GraphQL backend, requiring only the very simple GraphQL schema we’ve been considering so far as an input.
        </p>

        <p>
          [diagram]
        </p>

        <p>
          The GraphQL schema would be provided to the schema converter, which would generate a database schema and create the database, and also generate the necessary resolvers to initialize the GraphQL server. The GraphQL server would then produce the GraphQL API that could receive and respond to GraphQL requests from frontend applications.
        </p>

        <h3 id="what-about-more-complicated-data">6.3) What About More Complicated Data?</h3>

        <p>
          So far we had only looked at a very simple schema - too simple really to make a very interesting application out of. 
        </p>

        <p>
          When we started experimenting with more complicated schema, the difficulty in creating the database schema and resolver functions increased dramatically. For an only slightly-more-complicated example like we see here, we would need to define multiple tables, foreign keys, and constraints in order to make the database work for the data represented by the GraphQL schema. 
        </p>

        <p>
          [diagram]
        </p>

        <p>
          Although we were confident that it would still be theoretically possible to pull this off, we thought that now it would be a good time to take a step back and consider alternatives.
        </p>

        <h3 id="graph-databases">6.4) Graph Databases</h3>

        <p>
          This led us to consider other kinds of databases, and we ultimately ended up at Graph databases.
        </p>

        <h4>6.4.1) What are Graph Databases?</h4>

        <p>
          Graph databases are databases specialized to handle highly interconnected data. They do this by treating their data as a graph - which is similar to how GraphQL treats its data. In fact, some Graph databases even have integrations with GraphQL to generate resolvers - exactly what we were looking for.
        </p>

        <h4>6.4.2) Graph Databases and GraphQL</h4>

        <p>
          Two graph databases with GraphQL integrations are neo4j and Dgraph.  Neo4j is probably the most widely used graph database.  It’s GraphQL integration involves using an add-on to the database, which was a more complicated setup than we were hoping for.
        </p>

        <p>
          Dgraph is less well-known that neo4j, but has a native GraphQL integration, meaning you don’t have to install any other addons - you get the GraphQL API directly from the database.
        </p>

        <p>
          [diagram - neo4j and dgraph check and x]
        </p>

        <p>
          Because of its native GraphQL support, we ultimately chose Dgraph for the database of Satellite.
        </p>

        <h4>6.4.3) Simplified Architecture</h4>

        <p>
          We could now simplify our hypothetical architecture.
        </p>

        <p>
          [diagram]
        </p>

        <p>
          With Dgraph accepting a GraphQL schema as an input, we would no longer need a schema converter to generate a database schema and resolvers or a separate application server to serve the API, so we were able to remove those components from the architecture.
        </p>

        <h3 id="other-challenges">6.5) Other Challenges</h3>

        <p>
          Although the majority of the heavy lifting was done, we had a couple of additional problems to solve before we could get to Satellite’s final architecture.
        </p>

        <h4>6.5.1) How Does Satellite Backend Administration Work?</h4>
        
        <p>
          In addition to the GraphQL endpoint, Dgraph exposes administrative endpoints for interacting with its GraphQL schema, such as updating the schema and inspecting the currently loaded schema.  We knew that the front-end developer would need to access these administrative endpoints as they worked with Satellite, but that these endpoints shouldn’t be accessible from the public internet. As it was, we had no way of making only the GraphQL endpoint public to the internet, while keeping the admin endpoint private.
        </p>

        <p>
          [diagram]
        </p>

        <p>
          Also, we currently have no way to upload or serve static files - files that a front-end developer would likely need for their web applications.
        </p>

        <h4>6.5.2) Protecting the Administrative Endpoints</h4>
        
        <p>
          To protect these private endpoints, we needed a couple more components.
        </p>

        <p>
          The two components we needed were an nginx webserver to serve static files and act as an a reverse proxy to the GraphQL API endpoint of Dgraph, and a NodeJS application to provide a way for the developer to upload their static files and perform administrative actions to Dgraph’s admin endpoint.
        </p>

        <p>
          [diagram - nginx and node checks]
        </p>

        <p>
          Nginx was an obvious choice for an efficient and battle-tested webserver to act as the internet-facing entry point to a Satellite backend - and NodeJS running a simple express application worked perfectly for providing a private API that the front-end developer could access to upload their static files and work with the GraphQL schema loaded to Dgraph.
        </p>

        <h3 id="the-core-application-final-architecture">6.6) The Core Application Final Architecture</h3>

        <p>
          This brings us to the final architecture for the Satellite core application, which we can now see in more detail.
        </p>

        <p>
          [diagram]
        </p>

        <p>
          The nginx webserver acts as a web-facing entry-point to the backend, reverse proxying GraphQL requests to Dgraph or serving static files.  The NodeJS application provides a private entry-point for the developer to perform administrative actions to their backend, like uploading static files, or updating their GraphQL schema.
        </p>

        <h3 id="how-do-we-simplify-deployment">6.7) How do we Simplify Deployment?</h3>

        <p>
          As it stands, to get a single Satellite application running, you’d have to manually download and configure each component individually, specific to whatever operating system you’re trying to run it on. This would be a very time-consuming and generally just difficult process. The problem we faced now was - How can we package all of the components of a single Satellite application and their dependencies in a way that it can be deployed easily wherever it’s needed?
        </p>

        <h4>6.7.1) Containers</h4>
        
        <p>
          The answer to this problem was to use containers.
        </p>

        <p>
          Containers provide a way to package an application with its dependencies in an isolated and consistent way.  This means that if you start, for example, a NodeJS container, that container has all of the requirements to run NodeJS packaged with it, and you no longer have to worry about manually installing it and setting everything up. The isolation of containers means that whatever is going on inside the container doesn’t interfere with the host system - so if you run a container with one version of Node on it, it won’t interfere with your host installation of Node.
        </p>

        <p>
          [diagram]
        </p>

        <p>
          Another good thing about containers is that they are lighter weight than some other options like virtual machines. Virtual machines actually require running an entire guest operating system, while containers run directly within the host operating system and use less resources. This makes containers faster to deploy. And since Docker is the most popular way to package applications using containers, we chose to use Docker containers to package the components of Satellite.
        </p>

        <h4>6.7.2) Container Coordination</h4>
        
        <p>
          Packaging Satellite using docker containers greatly simplified the deployment of each individual component. But since each Satellite consists of multiple components, it still required manually starting and stopping each container for the application.
        </p>

        <p>
          Our final optimization for running a single Satellite was to eliminate this need for starting each container individually.  We wanted to make it possible to start the application with only a single command. Fortunately, Docker provides a tool called Docker Compose, which is designed specifically for defining and running multi-container Docker applications. Compose uses a YAML file to declaratively describe the containers you want to run, which the Docker Compose tool uses to launch the containers with the required configurations.
        </p>

        <p>
          [diagram]
        </p>

        <p>
          Our docker compose configuration for launching a single, containerized Satellite looked something like what is pictured here. As you can see, the compose file also allows for specifying various other options that are required for Satellite to run, such as environment variables and storage volumes used by the containers to store their data.
        </p>

        <h2 id="multi-instance-architecture">7) Multi Instance Architecture</h2>       

      <section id="footnotes">
        <h2 id="references">8) References</h2>

        <ol>
          <li id="footnote-1">
            <a
              href="https://pragprog.com/titles/sbsockets/real-time-phoenix/"
              target="_blank"
              >https://pragprog.com/titles/sbsockets/real-time-phoenix/</a
            >
          </li>
          <li id="footnote-2">
            <a href="https://hpbn.co/brief-history-of-http/" target="_blank"
              >https://hpbn.co/brief-history-of-http/</a
            >
          </li>
          <li id="footnote-3">
            <a
              href="https://hpbn.co/websocket/#performance-checklist"
              target="_blank"
              >https://hpbn.co/websocket/#performance-checklist</a
            >
          </li>
        </ol>
      </section>
    </section>
  </main>

  <section id="our-team">
    <h1>Our Team</h1>

    <p>
      We are looking for opportunities. If you liked what you saw and want to
      talk more, please reach out!
    </p>

    <ul>
      <li class="individual">
        <img
          src="images/avatars/avatar-placeholder.png"
          alt="John Smith"
        />

        <h3>John Smith</h3>

        <p>Anytown, USA</p>

        <ul class="social-icons">
          <li>
            <a href="mailto:wgatever@gmail.com" target="">
              <img src="images/icons/email_icon.png" alt="email" />
            </a>
          </li>

          <li>
            <a href="https://www.google.com/" target="_blank">
              <img src="images/icons/website_icon.png" alt="website" />
            </a>
          </li>

          <li>
            <a
              href="https://www.linkedin.com/in/somebody/"
              target="_blank"
            >
              <img src="images/icons/linked_in_icon.png" alt="linkedin" />
            </a>
          </li>
        </ul>
      </li>
      <li class="individual">
        <img
          src="images/avatars/avatar-placeholder.png"
          alt="John Smith"
        />

        <h3>John Smith</h3>

        <p>Anytown, USA</p>

        <ul class="social-icons">
          <li>
            <a href="mailto:wgatever@gmail.com" target="">
              <img src="images/icons/email_icon.png" alt="email" />
            </a>
          </li>

          <li>
            <a href="https://www.google.com/" target="_blank">
              <img src="images/icons/website_icon.png" alt="website" />
            </a>
          </li>

          <li>
            <a
              href="https://www.linkedin.com/in/somebody/"
              target="_blank"
            >
              <img src="images/icons/linked_in_icon.png" alt="linkedin" />
            </a>
          </li>
        </ul>
      </li>

      <li class="individual">
        <img
          src="images/avatars/avatar-placeholder.png"
          alt="John Smith"
        />

        <h3>John Smith</h3>

        <p>Anytown, USA</p>

        <ul class="social-icons">
          <li>
            <a href="mailto:wgatever@gmail.com" target="">
              <img src="images/icons/email_icon.png" alt="email" />
            </a>
          </li>

          <li>
            <a href="https://www.google.com/" target="_blank">
              <img src="images/icons/website_icon.png" alt="website" />
            </a>
          </li>

          <li>
            <a
              href="https://www.linkedin.com/in/somebody/"
              target="_blank"
            >
              <img src="images/icons/linked_in_icon.png" alt="linkedin" />
            </a>
          </li>
        </ul>
      </li>

      <li class="individual">
        <img
          src="images/avatars/avatar-placeholder.png"
          alt="John Smith"
        />

        <h3>John Smith</h3>

        <p>Anytown, USA</p>

        <ul class="social-icons">
          <li>
            <a href="mailto:wgatever@gmail.com" target="">
              <img src="images/icons/email_icon.png" alt="email" />
            </a>
          </li>

          <li>
            <a href="https://www.google.com/" target="_blank">
              <img src="images/icons/website_icon.png" alt="website" />
            </a>
          </li>

          <li>
            <a
              href="https://www.linkedin.com/in/somebody/"
              target="_blank"
            >
              <img src="images/icons/linked_in_icon.png" alt="linkedin" />
            </a>
          </li>
        </ul>
      </li>
    </ul>
  </section>

  </body>

  </html>