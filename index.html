<!DOCTYPE html>

<html lang="en-US" prefix="og: http://opg.me/ns#">
  <head>
    <meta charset="UTF-8" />

    <meta name="title" property="og:title" content="Satellite" />

    <meta
      name="description"
      property="og:description"
      content="Satellite is an open-source GraphQL Backend-as-a-Service that makes it easy to get a GraphQL API up and running to power the frontend of your dynamic web application."
    />

    <meta name="type" property="og:type" content="website" />

    <meta
      name="url"
      property="og:url"
      content="https://satellite-baas.github.io/"
    />

    <meta
      name="image"
      property="og:image"
      content="images/logos/satellite-full.png"
    />

    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta
      name="author"
      content="Will Baker, Ilyas Kussainov, Jordan Moore, Lewis Reynolds"
    />

    <title>Satellite</title>

    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="/images/icons/favicons/apple-touch-icon.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="/images/icons/favicons/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="/images/icons/favicons/favicon-16x16.png"
    />
    <link rel="manifest" href="/images/icons/favicons/site.webmanifest" />
    <link
      rel="mask-icon"
      href="/images/icons/favicons/safari-pinned-tab.svg"
      color="#5366f5"
    />

    <link rel="shortcut icon" href="/images/icons/favicons/favicon.ico" />
    <meta name="msapplication-TileColor" content="#da532c" />
    <meta
      name="msapplication-config"
      content="/images/icons/favicons/browserconfig.xml"
    />
    <meta name="theme-color" content="#ffffff" />

    <!-- <style>reset</style> -->

    <link rel="stylesheet" href="stylesheets/reset.css" />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/gruvbox-dark.min.css"
      charset="utf-8"
    />

    <!-- <style></style> -->

    <link rel="stylesheet" href="stylesheets/main.css" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

    <!-- <script></script> -->

    <script src="javascripts/application.js"></script>

    <style></style>
  </head>

  <body>
    <div class="logo-links">
      <p id="satellite-logo">MENU</p>

      <a href="https://github.com/satellite-baas" target="_blank">
        <img
          src="images/logos/github-black.png"
          alt="github logo"
          id="github-logo"
        />
      </a>
    </div>
    <a id="toTop-link" href="#" target="_blank">
      <img
        src="images/logos/back-to-top.png"
        alt="Back to top"
        id="toTop-logo"
      />
    </a>
    <nav id="site-navigation">
      <ul>
        <li>
          <a href="#home" id="home-link">HOME</a>
        </li>

        <li>
          <a href="#case-study" id="case-study-link">CASE STUDY</a>

          <nav id="case-study-mobile">
            <ul></ul>
          </nav>
        </li>

        <li>
          <a href="#our-team" id="our-team-link">OUR TEAM</a>
        </li>
      </ul>
    </nav>

    <header id="home">
      <h1>
        <img
          id="hero-logo"
          src="images/logos/satellite-hero.png"
          alt="Satellite logo"
        />
        <p>A GraphQL Backend-as-a-Service for dynamic web applications</p>
      </h1>
    </header>

    <section class="integration">
      <div class="box">
        <img
          id="banner-deploy"
          src="images/gifs/add-data.gif"
          alt="Satellite UI"
        />
      </div>

      <article class="box">
        <div class="text-box">
          <h3>Placeholder</h3>
          <p>Show the usage of Satellite GUI</p>
        </div>
      </article>
    </section>

    <section class="integration">
      <article class="box">
        <div class="text-box">
          <h3>Placeholder</h3>
          <p>Some other aspect of usage</p>
        </div>
      </article>

      <div class="box">
        <img
          id="banner-deploy"
          src="images/gifs/spin-up-satellite.gif"
          alt="Satellite UI"
        />
      </div>
    </section>

    <section class="integration">
      <div class="box">
        <img
          id="rocket-logo"
          src="images/logos/768px-rocket.png"
          alt="A launching rocket logo"
        />
      </div>

      <article class="box">
        <div class="text-box">
          <h3>Placeholder</h3>
          <p>Something about deployment</p>
        </div>
      </article>
    </section>

    <main>
      <section id="case-study">
        <h1>Case Study</h1>

        <div id="side-nav">
          <img src="images/logos/satellite-mark.png" alt="Satellite logo" />
        </div>

        <nav>
          <ul></ul>
        </nav>

        <h2 id="what-is-satellite">1) What is Satellite?</h2>

        <p>
          Satellite is an open-source GraphQL backend-as-a-service (BaaS). It lets teams easily deploy and manage GraphQL backends for web applications.
        </p>

        <p>
          Satellite abstracts away the complexity of building a GraphQL backend. It lets the application developer define their entire backend using only a single input - a GraphQL schema. Satellite's multi-tenant architecture, based on Kubernetes, lets developers create and use as many backends as they need. Satellite is a great fit for new applications where ease of use and quick deployment are priorities.
        </p>

        <p>
          In this case study, we'll describe both <em>why</em> and <em>how</em> we designed and built Satellite. Satellite was born from our desire to make setting up a GraphQL backend easier. We overcame many technical challenges to achieve this. 
        </p>

        <p>
          To explain Satellite's design, we'll first discuss the general architecture of a modern web application. We'll also describe how challenges faced by Facebook's News Feed API drove the development of GraphQL.
        </p>

        <h2 id="web-app-architecture">2) Web App Architecture</h2>

        <h3 id="frontend-vs-backend">2.1) Frontend vs Backend</h3>

        <p>
          Web applications can be thought of as having two parts - the frontend and the backend. The frontend is what the user sees when using the application. It is responsible for the application's appearance and for handling user interactions. On the other side of an application is the backend. It handles the business logic and data persistence operations needed to power the frontend.
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/2_1-front-back.svg"
            alt="The two parts of a web application."
          />
        </div>

        <p>
          Modern applications often completely separate the backend from the frontend. This kind of split architecture allows frontend and backend teams to work independently. It also allows development of different frontend client applications which use the same backend [<a href="#footnote-1">1</a>]. Given the advantages of this decoupled architecture, we need to think about how the frontend and backend communicate. 
        </p>

        <h3 id="api-s-in-web-applications">
          2.2) How do the Frontend and Backend Communicate?
        </h3>

        <p>
          An API, or Application Programming Interface, provides a well-defined way for computer systems to interact with each other. There are many different types of APIs. They all provide some way for one system to access the functionality of another system. It makes sense, then, for the frontend of a web application to communicate with the backend using an API [<a href="#footnote-2">2</a>]. An API that lets a frontend and backend communicate using HTTP is called a web API. In a web API, the backend server produces the API and the frontend client consumes it. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/2_2-api-ex.svg"
            alt="Frontend to backend communication with an API."
          />
        </div>

        <p>
          There are many different ways to build a web API. The state-of-the-art for web APIs has evolved over the years, and API designers are always finding better solutions to the challenges they are facing.
        </p>

        <h3 id="facebook-s-news-feed-api">
          2.3) Designing a Better API: Facebook's News Feed
        </h3>

        <p>
          This story starts in 2011, when Facebook decided to completely re-write their iOS app. Previously, their mobile app had, essentially, been a wrapper around the Facebook webpage. They determined they needed to create a new, native app to provide the kind of experience they wanted for their mobile users. Their design required the frontend to be separated from the backend, and for the two sides to communicate with an API. This was the first time Facebook had tried to develop and app like this. They soon had issues when trying to reuse the existing API for the News Feed feature [<a
            href="#footnote-3"
            >3</a
          >].
        </p>

        <h4>2.3.1) Why the Existing API Didn't Work</h4>

        <p>
          For Facebook’s News Feed, it wasn’t as simple as retrieving a story and all the information for that particular story. Each story is interconnected, nested, and recursive. The existing APIs weren’t designed to allow developers to deliver a rich, news feed-like experience on mobile. They didn’t have a hierarchical nature or let developers select the exact data they needed. They were, in fact, designed to return HTML back to a web browser.
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/2_3_1-facebook-api-1.svg"
            alt="An inefficient API interaction."
          />
        </div>

        <p>
          This meant that the client application would need to make several round-trips to the API to get the information it wanted. For example, it might have to first get one story, and from it determine what other stories it needed to request to complete the feed. Then it might keep repeating that process over and over until it got all the information it needed. Additionally, each response would contain a lot of data that wasn’t needed. Both of these factors combined resulted in slow network performance for the new app. 
        </p>

        <h4>2.3.2) Why Facebook Created GraphQL</h4>

        <p>
          At this point, it was clear to Facebook that they needed to design a better API for their News Feed to improve the mobile experience. A quote from Nick Schrock, one of the co-creators of this new API which is now called GraphQL, highlights their focus on frontend development:
        </p>

        <blockquote>
          <i
            >"We tried to design what we thought was the ideal API for frontend
            developers, and then work backwards to the technology."</i
          >
          <br /><br />
          - Nick Schrock, GraphQL co-creator
        </blockquote>

        <p>
          A key feature of GraphQL let it power the mobile apps Facebook had envisioned: it let the frontend client request exactly the data it needs. This eliminates the issue of over-fetching and the need for multiple round trips. This is critical for mobile applications which have limited bandwidth and need fast response times. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/2_3_2-facebook-api-2.svg"
            alt="An API interaction with GraphQL."
          />
        </div>

        <p>
          One other important aspect of a GraphQL API is that it uses a strongly typed system to describe its capabilities. This allows clients to use a process called introspection to see exactly what they are able to do with the API, making GraphQL effectively self-documenting [<a href="#footnote-4">4</a>]. This has also lead to the development of many client-side tools.
        </p>

        <h4>2.3.3) Widespread Adoption of GraphQL</h4>

        <p>
          Because of its unique features, GraphQL caught on quickly at Facebook, and ended up being used heavily in their mobile application. It was an internal tool from 2012 until 2015; that year, they released an open-source version. Soon after GraphQL was open-sourced, many other companies began using it, including AirBnB, Twitter, Netflix, and Github. It has continued to grow in adoption ever since [<a href="#footnote-5">5</a>].
        </p>

        <p>
          Now that we understand the types of problems that GraphQL was created to solve, we can take a closer look at what GraphQL is and how it works.
        </p>

        <h2 id="what-is-graphql">3) What is GraphQL?</h2>

        <p>
          GraphQL is a query language for APIs. In this section, we'll explain in more depth how it works and what is involved in building a GraphQL application.
        </p>

        <h3 id="the-graphql-specification">3.1) The GraphQL Specification</h3>

        <p>
          GraphQL is actually a specification that describes its type system and query language [<a href="#footnote-6">6</a>]. Both of these will be covered in more detail later. For now, keep in mind that this specification can be implemented in any programming language. It's not specific to any one application or architecture. There are, in fact, server-side implementations of the GraphQL specification in many programming languages. These server-side implementations are called GraphQL servers. 
        </p>

        <h3 id="graphql-servers">3.2) GraphQL Servers</h3>

        <p>
          GraphQL servers communicate with clients using standard HTTP. The GraphQL server parses the request into an abstract syntax tree, or AST, then walks this tree and determines how to respond to the request. Once the GraphQL server has assembled the request, the request is returned to the client as a JSON object - once again over standard HTTP.
        </p>

        <h3 id="interacting-with-a-graphql-api">
          3.3) Interacting with a GraphQL API
        </h3>

        <p>
          With the GraphQL specification implemented on the server, the frontend can query it. Since the data is defined according to GraphQL's type system, the frontend structures its queries according to those types. The frontend can then specify exactly the data it wants in a query to the GraphQL server. The server will return that data in a JSON object. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/3_3-graphql-overview.svg"
            alt="GraphQL - Describe your data, ask for what you want, and get predictable results."
          />
        </div>

        <p>
          Enabling this kind of interaction for frontend clients worked great for Facebook's News Feed API. How, then, would somebody go about setting up the backend for their own GraphQL API?
        </p>

        <h2 id="graphql-backends">4) GraphQL Backends</h2>
        <p>
          You should now have an idea of what kind of problems GraphQL was created to solve and a general understanding of how it works. You might even be interested in creating your next application using a GraphQL API. There are several factors to consider if you do, though.
        </p>

        <p>
          First, we'll cover the overall architecture required for a web application backend.
        </p>

        <h3 id="backend-architecture">4.1) Backend Architecture</h3>

        <p>
          As a first step in understanding what it takes to build a GraphQL backend, let's take a look at the general setup for a backend:
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/4_1-normal-server.svg"
            alt="The 3-tier architecture of a backend."
          />
        </div>

        <p>
          A backend is usually built with a 3-tier architecture [<a href="#footnote-7">7</a>]. The different "tiers" in this kind of architecture serve the following purposes:
        </p>

        <ul>
          <li>
            <b>Web Server:</b>: The web server acts as the internet-facing entry point to the backend. Web servers are highly optimized to handle requests involving <em>static</em> data, such as static file serving and caching. They can typically handle large volumes of requests for this kind of data. If the web server cannot fulfill requests directly, it forwards requests to the rest of the backend. 
          </li>

          <li>
            <b>Application Server:</b>: The application server is where requests for <em>dynamic</em> data end up. It handles processing and fulfilling those requests. The application server is where the business logic that powers the application resides. The application server doesn't persist data itself, though. If a request needs access to persistent data, the application server will need to access some kind of underlying data store. 
          </li>

          <li>
            <b>Database:</b>: The database provides long-term data persistence to the application server. Interaction with the database must go through the application server.  
          </li>
        </ul>

        <p>
          This kind of architecture is the foundation for building any feature our application might need.
        </p>

        <h3 id="backend-features">4.2) Backend Features</h3>
        <p>
          Given the basic architecture of a backend, we can start to imagine all the different things that a backend might need to do. These might include enabling SSL connections, managing realtime connections, providing hosting for frontend assets, and more. These all need to be set up and configured. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/4_2-backend-features.svg"
            alt="A few of the many different features that a backend is responsible for."
          />
        </div>

        <p>
          Any one of these tasks is a topic unto itself. For the backend of a GraphQL application, though, producing the GraphQL API is a subject we'll need to explore further. 
        </p>

        <h3 id="what-are-the-challenges-of-a-graphql-api">
          4.3) What are the Challenges of a GraphQL API?
        </h3>

        <p>
          Individual developers and companies have mentioned the challenges
          associated with implementing GraphQL in production applications.
        </p>

        <p>
          Arnaud Lauret, author of the book "The Design of Web APIs", mentions
          the new challenges that a GraphQL API brings [<a href="#footnote-8"
            >8</a
          >]:
        </p>

        <blockquote>
          <i
            >“GraphQL does not ease an API provider’s job and brings new
            challenges.”</i
          >
          <br /><br />
          - Arnaud Lauret, author of The Design of Web APIs
        </blockquote>

        <p>
          In an article from PayPal's engineering blog, a similar challenge is
          mentioned - GraphQL is different than what developers may be used to
          [<a href="#footnote-9">9</a>]:
        </p>

        <blockquote>
          <i
            >“Ensure that architects and API designers are on board with GraphQL
            ... More than likely, they have designed REST APIs for years.
            GraphQL is different.”</i
          >
          <br /><br />
          - Scaling GraphQL at Paypal - Paypal Engineering Blog
        </blockquote>

        <p>
          With this in mind, we are ready to proceed with discussing how one
          goes about producing a GraphQL API.
        </p>

        <h3 id="how-is-a-graphql-api-produced">
          4.4) How is a GraphQL API Produced?
        </h3>

        <p>
          To produce a GraphQL API, we need to run a GraphQL server. As we mentioned earlier, a GraphQL server is software that can receive and respond to GraphQL requests. The behavior of a GraphQL server is defined using two inputs: a GraphQL schema and resolver functions. At a high level, the GraphQL schema defines “what” the GraphQL server can do using the GraphQL type system, and the resolver functions tell it “how” to do it [<a href="#footnote-10">10</a>].
        </p>

        <p>
          A diagram of a GraphQL server is shown here. A GraphQL schema defines the GraphQL API. Then the API invokes the necessary resolver functions. Finally, the the resolvers carry out the actions needed to produce the response, such as querying a database: 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/4_4-graphql-server.svg"
            alt="A GraphQL server."
          />
        </div>

        <p>
          Next, we'll take a look at the GraphQL schema and resolver functions in a little more detail, to better appreciate what goes into creating them. 
        </p>

        <h4>4.4.1) GraphQL Schema</h4>

        <p>
          The GraphQL schema declaratively defines the functionality of the GraphQL API [<a href="#footnote-11">11</a>]. The schema is made up of types, and the types have one or more fields. 
        </p>

        <p>
          A basic GraphQL schema is shown here. It has several types - the “Person” type is an object type. Object types make up the “things” of your API. Each type will also have fields. For the Person here, there is a name and phone field, which are a string and integer. You can think of fields like the properties of your objects.
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/4_4_1-graphql-schema.png"
            alt="A GraphQL schema."
          />
        </div>

        <p>
          There are many more types than just objects. Two important ones are the query and mutation types. These describe what actions you can do with your object types. Queries define how to retrieve data, while mutations define how to create or change the data. Here we have a query to find a person by name, and a mutation to create a new person. 
        </p>

        <p>
          Keep in mind that these definitions of queries and mutations don’t say anything about <em>how</em> the API gets the job done. They only describe what the API can do! 
        </p>

        <h4>4.4.2) GraphQL Resolvers</h4>

        <p>
          Resolvers are functions that tell the GraphQL server how to respond to
          requests.
        </p>

        <p>
          Unlike the schema, which has to follow the requirements of the GraphQL specification, resolvers are flexible. They are just functions, and you can do anything with them that you would do with any other function. The only requirement is that the function needs to return a value which corresponds to the field specified by the schema [<a href="#footnote-12">12</a>].
        </p>

        <p>
          In this example, the resolvers correspond to the respective query and mutation types that were defined in the GraphQL schema.
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/4_4_2-graphql-resolver.png"
            alt="Some GraphQL resolvers."
          />
        </div>

        <p>
          With the GraphQL schema and resolver functions defined, we have everything we need to initialize the GraphQL server to produce the GraphQL API. 
        </p>

        <h3 id="how-can-we-reduce-the-complexity-of-a-graphql-backend">
          4.5) How Can we Reduce the Complexity of a GraphQL Backend?
        </h3>

        <p>
          We can now see the big picture of what goes into creating a GraphQL backend. Besides the architecture and configuration needed for a standard backend, there are also the inputs needed to define the GraphQL API: the schema and resolver functions.
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/4_5_1-full-backend.svg"
            alt="All of the architecture and inputs required to make a GraphQL backend."
          />
        </div>

        <p>
          For a frontend developer wanting to get a GraphQL application up and running quickly, that’s a lot to think about. Because of this, we wondered if there might be a way to make it easier for frontend developers to get a simple GraphQL backend up and running quickly. 
        </p>

        <p>
          Ideally, the developer wouldn’t have to think about the backend design at all. The standard backend components and configuration should be set up automatically. So should the lower-level GraphQL configuration, like resolver functions.
        </p>

        <p>
          In order to solve the aforementioned problems, we decided to build a backend-as-a-service (BaaS). A BaaS provides an abstraction over all the functionality and complexity of the backend. It seemed like a good way to simplify setting up a GraphQL backend. 
        </p>

        <h2 id="backend-as-a-service">5) Backend-as-a-Service</h2>

        <h3 id="what-is-a-backend-as-a-service-baas">
          5.1) What is a Backend-as-a-Service (BaaS)?
        </h3>

        <p>
          A BaaS encapsulates the underlying architecture that a backend needs - the web server, app server, and database. It also provides pre-configured features like SSL certificates and static frontend hosting. The functionality of the backend is made available to frontend applications through an API [<a href="#footnote-13">13</a>].
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/5_1-backend-as-a-service.svg"
            alt="A backend as a service."
          />
        </div>

        <p>
          With a BaaS, you simply ask for a backend to be created. Then it gives you an endpoint to access that backend's functionality.
        </p>

        <h3 id="why-use-a-baas">
          5.2) What are the tradeoffs of using a BaaS?
        </h3>

        <p>
          As we've seen, a BaaS facilitates frontend development. It abstracts away the complexity of the backend, allowing for faster application development. 
        </p>

        <p>
          This abstraction does come with costs, though. For example, the BaaS itself still requires setup and maintenance. Also, with these kinds of services, as you gain more abstraction you sacrifice control. The table below shows how a BaaS compares to two other services which provide abstraction over backend concerns: infrastructure-as-a-service (IaaS) and platform-as-a-service (PaaS). 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/5_2-abstraction-vs-control1.png"
            alt="BaaS tradeoffs - abstraction vs. control."
          />
        </div>

        <p>
          An IaaS provides the lowest level of abstraction. The developer configures everything from the operating system on up. That makes it low in abstraction but high in control. 
        </p>

        <p>
          A PaaS provides more abstraction than an IaaS, but less than a BaaS. The developer provides all the application code for the backend. The platform handles the operating system configuration and deployment. 
        </p>

        <p>
          At the highest level of abstraction is a BaaS. The developer no longer needs to provide any backend code or handle any backend configuration. But they aren't able to control much, if anything, about how the service works internally.
        </p>

        <p>
          Giving up control over the internals of the backend seemed like a reasonable trade-off for an application which prioritizes rapid development.
        </p>

        <h3 id="existing-graphql-baas">5.3) Existing GraphQL BaaS</h3>

        <p>
          As you might guess, there are several existing GraphQL BaaS options to chose from. These can be grouped into two general categories: managed services and open-source solutions.
        </p>

        <h4>5.3.1) Managed Services</h4>

        <p>
          There are several managed services available for a GraphQL BaaS. These are paid, proprietary services and are fully supported by the provider. Using a paid service takes care of all the details of setting up and managing the backend of your application. In general, they are easy to use - with some caveats. <a href="https://aws.amazon.com/amplify/">AWS Amplify</a>, for example, has a close integration with other AWS services. That makes it a great option if you are committed to using AWS services for your entire application. It's possible, but more difficult, to use it with non-AWS services. Since there is no need to deploy anything to use these managed services, they're very simple to use. 
        </p>

        <p>
          These managed services also tend to have a many features. Services like <a href="https://www.8base.com/">8Base</a> and <a href="https://nhost.io/">Nhost</a> provide just about any feature you could ever want from your backend even beyond the GraphQL API. <a href="https://dgraph.io/slash-graphql">Slash GraphQL</a> has comparatively fewer features. It does, though, have some advanced options like the ability to run custom logic via serverless lambda functions. 
        </p>

        <h4>5.3.2) Open-Source Solutions</h4>

        <p>
          For open-source options, the most popular is probably <a href="https://parseplatform.org/">Parse Platform</a>. Parse is a self-hosted platform that provides a backend with all the features you could need for your application, including a GraphQL API. Unlike the managed services, you can host Parse anywhere you want. It gives you full control over your data and infrastructure. 
        </p>

        <p>
          Another, less well-known GraphQL BaaS is <a href="https://spaceuptech.com/">Spacecloud</a>. It offers a similar wide range of features as Parse and also lets you self-host it wherever you want. 
        </p>

        <h3 id="why-not-use-an-existing-graphql-baas">
          5.4) Why Not Use an Existing GraphQL BaaS?
        </h3>

        <p>
          While the existing GraphQL BaaS options have many useful features,
          they have their own set of tradeoffs as well.
        </p>

        <p>
          Although managed services need minimal effort to deploy and are generally easy to use, they are of course not fully open-source. With these services, you don’t have any control over how your application and its data is hosted. You also run the risk of vendor lock-in if your application ever outgrows the BaaS. 
        </p>

        <p>
          With the existing open source options, you maintain control of your data, but have more complicated deployment and usage. You will need to worry about things like selecting and configuring a database with both Parse and Spacecloud, for example. With their wide range of features and options, it can take some time to learn how to use them once they are deployed. 
        </p>

        <h3 id="where-does-satellite-fit">5.4) Where Does Satellite Fit?</h3>

        <p>
          After reviewing the existing BaaS options, we saw that there was an opportunity for a self-hosted GraphQL BaaS that is easy to deploy and use. Two main things influenced our idea. One is the simplicity of managed services. The other is the ability to self-host an open-source solution and maintain full control of an application and data. 
        </p>

        <p>
          The table below shows where Satellite fits compared to some existing
          options:
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/5_4_option-comparison-table.png"
            alt="How Satellite compares to existing BaaS options."
          />
        </div>

        <p>
          Compared to the other GraphQL BaaS options that are available, Satellite has fewer features. We kept it that way to simplify deployment and ensure that it was intuitive to use. Like other existing open-source options, you can host Satellite anywhere you’d like.
        </p>

        <p>
          Since Satellite doesn’t have a huge number of features, it won't be a good fit for every application. But if you want an open-source solution to quickly get a GraphQL backend running with only minimal features, Satellite might be a good option.
        </p>

        <h2 id="the-core-application">6) The Core Application</h2>

        <p>
          The Satellite core application represents a single backend instance. It provides a GraphQL API for client applications to access and a persistent data store and static file serving for frontend hosting.
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/6_1-core-architecture-simple.svg"
            alt="Satellite's core application architecture - high level."
          />
        </div>

        <p>
          These features are made possible using several components under the hood. First is an Nginx web server, used for serving static files and routing incoming requests. Next is a NodeJS Express application server, which allows administrative actions to be made on the Satellite instance. Finally, a Dgraph graph database is used to store persistent data. 
        </p>

        <p>
          Our priority while designing Satellite was to keep it easy to use. In this rest of this section, we'll explain the main problems we had to solve to achieve that goal. We'll also explain how solving them led to this architecture. 
        </p>

        <h3 id="how-is-an-application-s-data-defined">
          6.1) How is an Application's Data Defined?
        </h3>

        <p>
          When we started building Satellite, we faced a question. How do we build a GraphQL backend that works for any application without knowing what kind of data that application will need ahead of time? We needed to build a “generic” GraphQL backend that would work for any application. 
        </p>

        <p>
          To answer that question, we had to determine the best way to allow a developer to define the structure of their application's data. 
        </p>

        <h4>6.1.1) GraphQL Schema vs. Database Schema</h4>

        <p>
          The backend for a GraphQL application will normally need to deal with interconnected, related data. One way to handle this is to use a relational database with a GraphQL layer over it. The GraphQL queries from the client would get translated to SQL queries by resolver functions. This solution has the drawback of needing two sets of schema - one for the relational database and one for the GraphQL API. 
        </p>

        <p>
          Requiring a database schema in addition to the GraphQL schema would add another piece of configuration that must be provided to the backend. That was something we wanted to avoid to keep Satellite simple. 
        </p>

        <h4>6.1.2) A Hypothetical Database Schema Generator</h4>

        <p>
          At first, we thought we could come up with a way to generate a relational database schema from a GraphQL schema. This would eliminate the need for two schemas and make it possible to define the structure of the backend's data using only a GraphQL schema. 
        </p>

        <p>But what would this look like? Would it even be possible?</p>

        <p>
          For a simple GraphQL schema, consisting of only a single object type like the one shown below, it's easy enough to see how this could work. We might be able to generate a database schema defining a table with columns corresponding to the object.  
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/6_1_2-schema-to-schema.png"
            alt="Generating a database schema from a simple GraphQL schema."
          />
        </div>

        <p>
          The logic for this hypothetical conversion process should be a simple matter of converting strings. For now, we were ready to proceed to the next step. 
        </p>

        <h3 id="how-is-an-application-s-data-accessed">
          6.2) How is an Application's Data Accessed?
        </h3>

        <p>
          Now that we had a way to define the data of an application, we needed
          a way to access the data.
        </p>

        <h4>6.2.1) Resolver Functions in a GraphQL BaaS</h4>

        <p>
          As we’ve mentioned, making the data available for a GraphQL backend requires a GraphQL server to serve the API. That GraphQL server also needs to contain resolver functions to know how to respond to requests. The challenge is that writing these resolver functions requires the developer to go "under the hood" and edit the backend’s code. To keep Satellite easy to use and preserve the encapsulation of the BaaS, this was a problem we wanted to avoid. 
        </p>

        <h4>6.2.2) A Hypothetical Resolver Function Generator</h4>

        <p>
          As a possible solution, we thought we could take a similar approach as we had for converting the GraphQL schema to a database schema. That approach would be to automatically generate resolver functions. There would be functions for the most common actions you might want to take with your application’s data - creating, reading, updating, and deleting [<a href="#footnote-14">14</a>]. Then the GraphQL server would be initialized with those functions. 
        </p>

        <p>
          Would it be possible to do this? We again considered our very simple GraphQL schema to consider what this resolver function generator might look like: 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/6_2_2-schema-to-resolvers.png"
            alt="Generating resolver functions from a simple GraphQL schema."
          />
        </div>

        <p>
          We would need four resolvers for each object type in the schema: a Query type for reading the data, and three Mutation types for creating, updating, and deleting. This was starting to get much more complicated, but still seemed doable. Since all the resolvers followed a similar pattern, we should be able to generate the correct function signatures and required database actions to make it work... at least for a simple schema like this. 
        </p>

        <p>
          Our imagined schema converter would no longer only be a matter of converting strings. Now it would need to generate functions, too. But, we still felt confident enough to proceed down this path. 
        </p>

        <h4>6.2.3) The Hypothetical Architecture</h4>

        <p>
          We could now envision a hypothetical architecture for our GraphQL backend. It would need only a GraphQL schema as an input. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/6_2_3-hypothetical-architecture.svg"
            alt="A hypothetical architecture for Satellite."
          />
        </div>

        <p>
          The schema converter would get the GraphQL schema. Then it would generate a database schema and create the database. Next, it would generate the necessary resolvers to initialize the GraphQL server. Finally, the GraphQL server would produce the GraphQL API. It could then receive and respond to GraphQL requests from frontend applications. 
        </p>

        <p>
          But like so many things in software engineering, it turned out to be more complicated than we had assumed. Keep reading to see how we solved the most significant challenge yet. 
        </p>

        <h3 id="what-about-more-complicated-data">
          6.3) What About More Complicated Data?
        </h3>

        <p>
          So far, we've only looked at a very simple schema - probably too simple to make an interesting application. 
        </p>

        <p>
          Difficulties arose with more complicated schema, though. Creating the database schema and resolver functions became much harder. The schema in the next figure shows some more complex behaviors that can be defined using the GraphQL type system: 
        </p>

        <ul>
          <li>
            The type <code>Person</code> has the fields <code>name</code>,
            <code>address</code>, and <code>friends</code>:

            <ul>
              <li>
                <code>name</code> has the <em>scalar</em> type of
                <code>String</code>. Scalar types are what we have been looking
                at so far. These types repesent a peice of concrete data.
              </li>
              <li>
                <code>address</code> has the type of <code>Address</code>. The
                type <code>Address</code> is also defined in the schema. This is
                a <em>user defined</em> type.
              </li>
              <li>
                <code>friends</code> refers to a <em>list</em> of user defined
                types - a list of <code>Person</code> types.
              </li>
            </ul>
          </li>

          <li>
            The type <code>Address</code> is similar to what we've seen so far,
            with all of its fields being scalar types.
          </li>
        </ul>

        <p>
          A schema like this allows the GraphQL API to handle relationships. That's a key feature of GraphQL, so it wasn't something we could ignore. But what would our imagined schema converter look like now?
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/6_3-complicated-schema.png"
            alt="More complicated conversion - the results are uncertain."
          />
        </div>

        <p>
          The schema converter would need to define multiple tables, foreign keys, and constraints. Besides this, we'd also have to think much harder about resolver generation.
        </p>

        <p>
          So far, we've been taking advantage of something called the default resolver. According to the GraphQL specification, every field in a GraphQL schema needs a resolver. If no resolver function is defined for a field, most GraphQL implementations will fall back to the default resolver [<a href="#footnote-15">15</a>]. The default resolver simply returns a property from the returned object with the relevant field name. For example, if we defined resolvers for every field of the simple schema we considered earlier, the resulting functions would look like this: 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/6_3-full-resolvers.png"
            alt="A full set of resolvers, without the implicit default resolvers."
          />
        </div>

        <p>
          See the extra resolvers defined for Person? These are usually handled
          behind the scenes by the default resolver.
        </p>

        <p>
          Clearly, with schema having fields that aren't simple scalar types, we could no longer rely on the default resolver. Our schema converter would need to be smart enough to traverse each type recursively, identify non-scalar fields and generate resolver functions for those fields. An algorithm like this would actually be similar in concept to how a GraphQL server converts an incoming request into an AST. 
        </p>

        <p>
          Although we were still confident we could pull this off, going this route looked like it would mean reinventing the wheel. So rather than do that, we thought it would be a good time to take a step back and consider alternatives.
        </p>

        <h3 id="graph-databases">6.4) Graph Databases</h3>

        <p>
          Our search for a simpler way to generate resolver functions from a GraphQL schema led us to consider other kinds of databases. Graph databases, in particular, showed promise.
        </p>

        <h4>6.4.1) What are Graph Databases?</h4>

        <p>
          Graph databases are specialized to handle highly interconnected data [<a href="#footnote-16">16</a>]. They do this by treating their data as a graph - which is similar to how GraphQL treats its data. In fact, some Graph databases even have integrations with GraphQL to generate resolvers, which is exactly what we were looking for.
        </p>

        <h4>6.4.2) Graph Databases and GraphQL</h4>

        <p>
          Two graph databases with GraphQL integrations are <a href="https://neo4j.com/labs/grandstack-graphql/">neo4j</a> and <a href="https://dgraph.io/">Dgraph</a>. Neo4j is the most widely used graph database [<a href="#footnote-17">17</a>]. Its GraphQL integration involves using an add-on to the database, which was a more complicated setup than we were hoping for.
        </p>

        <p>
          Dgraph is less well-known that neo4j, but it has native GraphQL integration. You don’t have to install any other addons - you get the GraphQL API directly from the database. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/6_4_2-graph-databases.png"
            alt="Two graph databases - Neo4j and Dgraph."
          />
        </div>

        <p>
          Because of its native GraphQL support, we chose Dgraph for Satellite's database. This greatly simplified our architecture. 
        </p>

        <h4>6.4.3) Simplified Architecture</h4>

        <p>
          Letting Dgraph handle resolver generation and serve the GraphQL API let us simplify our hypothetical architecture: 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/6_4_2-simplified-architecture.svg"
            alt="Simplified (hypothethical) architecture."
          />
        </div>

        <p>
          With Dgraph accepting a GraphQL schema as an input, we were able to remove two major components from our working design. We would no longer need a schema converter to generate a database schema and resolvers. We also wouldn't need a separate application server to serve the API.
        </p>

        <p>
          At this point, the majority of the heavy lifting was done. We still had a few more problems to solve before we could get to the final Satellite backend architecture, though. 
        </p>

        <h3 id="other-challenges">6.5) Other Challenges</h3>

        <h4>6.5.1) How Does Satellite Backend Administration Work?</h4>

        <p>
          Besides a GraphQL endpoint, Dgraph exposes administrative endpoints for interacting with its GraphQL schema. They can be used for updating the schema and viewing the currently loaded schema. The frontend Satellite user would need to access these admin endpoints, but they shouldn’t be accessible from the public internet. As it was, we had no way of making only the GraphQL endpoint public to the internet, while keeping the admin endpoint private. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/6_5_1-dgraph-admin-endpoints.svg"
            alt="Dgraph's administrative endpoints."
          />
        </div>

        <p>
          Also, we currently have no way to upload or serve static files that a front-end developer would need for their web applications. We needed a way to resolve both of these issues before we could declare victory.
        </p>

        <h4>6.5.2) Protecting the Administrative Endpoints</h4>

        <p>
          To protect Dgraph's administrative endpoints and deal with static files, we needed a couple more components.
        </p>

        <p>
          The first component we needed was a web server to serve static files and act as a reverse proxy to the GraphQL API endpoint that Dgraph provides. We chose Nginx for this since it's an efficient and battle-tested product [<a href="#footnote-18">18</a>].
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/6_5_2-protecting-endpoints.png"
            alt="Nginx and NodeJS separate the administrative endpoints from the public endpoints."
          />
        </div>

        <p>
          The second thing we needed was an application to provide a way for the developer to upload their static files. They should also be able to send administrative actions to Dgraph’s admin endpoint. We accomplished this by building an express application running on NodeJS to provide a private API. The front-end developer can access the API to upload their static files and work with the GraphQL schema loaded into Dgraph.
        </p>

        <h3 id="the-core-application-final-architecture">
          6.6) The Core Application Final Architecture
        </h3>

        <p>
          This brings us to the final architecture for the Satellite core application, which is shown below:
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/6_6-core-architecture-detailed.svg"
            alt="Satellite's core application architecture - in more detail."
          />
        </div>

        <p>
          The Nginx web server acts as a web-facing entry point to the backend. It can reverse-proxy GraphQL requests to Dgraph or serve static files. The NodeJS application provides a private endpoint for the developer. They can perform actions like uploading static files or updating their GraphQL schema.
        </p>

        <p>
          Satellite's core architecture makes it easy to use, but what about deployment? On one hand, we knew that we couldn't match the simplicity of deployment of a managed service. On the other, we needed to make it as easy as possible to deploy for Satellite to be a viable alternative. Next, we'll discuss why deployment at this stage in Satellite's development was a big problem, and what we did to fix it. 
        </p>

        <h3 id="how-do-we-simplify-deployment">
          6.7) How do we Simplify Deployment?
        </h3>

        <p>
          As it stands, to get a Satellite instance running, you’d have to manually download and configure each component. The specifics could change depending on which operating system you’re trying to run them on. This would be a very time-consuming and difficult process. We now had the challenge of packaging the components of a Satellite backend, plus their dependencies, in a way that was easy to deploy. 
        </p>

        <h4>6.7.1) Containers</h4>

        <p>
          After some investigation, we found a good answer to this: containers.
        </p>

        <p>
          Containers provide a way to package an application with its dependencies in an isolated and consistent way [<a href="#footnote-19">19</a>]. This means that if you start, for example, a NodeJS container, that container has all the requirements to run NodeJS packaged with it. You no longer have to worry about manually installing it and setting everything up. Containers also provide isolation, meaning that whatever is going on in the container doesn’t interfere with the host system. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/6_7_1-containers.svg"
            alt="How Docker containers interact with the host operating system."
          />
        </div>

        <p>
          Another good thing about containers is that they are lighter weight than some other options like virtual machines [<a href="#footnote-20">20</a>]. Virtual machines need to run a guest operating system. Containers, though, create an isolated environment within the host operating system. Since Docker is the most popular way to package applications using containers, we chose it to package the components of Satellite.
        </p>

        <h4>6.7.2) Container Coordination</h4>

        <p>
          Packaging Satellite using Docker containers greatly simplified the deployment of the individual components. But since a Satellite backend consists of several components, it still required manually starting and stopping each container.
        </p>

        <p>
          Our goal was to make it possible to start the application with only a single command. Fortunately, Docker provides a tool called <a href="https://docs.docker.com/compose/">Docker Compose</a>. It's designed for defining and running applications consisting of multiple Docker containers. Compose uses a YAML file to describe and configure the containers you want to run. Then it launches the containers to start the application. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/6_7_2-container-coordination.png"
            alt="Coordinating containers with docker compose."
          />
        </div>

        <p>
          Our Docker Compose configuration for launching a containerized backend looked something like this. As you can see, the compose file can also specify various other options needed for Satellite to run. It can include things like environment variables and storage volumes used by the containers to store their data. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/gifs/dc-spin.gif"
            alt="Spinning up a Satellite instance."
          />
        </div>

        <h2 id="multi-instance-architecture">7) Multi-Instance Architecture</h2>

        <p>
          At this point, we had a system that was easy to deploy and supported one Satellite instance. This would work fine for developers who only needed a single backend. But what about developers who wanted to run several backends at once? For example, it's often useful for an application to have multiple versions of its backend. This could be for supporting different versions of the app for staging and production [<a href="#footnote-21">21</a>]. It also seemed very possible that developers might want to host more than one application at a time.
        </p>
        
        <p>
          The question now became: how can we support easy deployment of multiple Satellite backends?
        </p>

        <h3>7.1) Why Multi-Instance?</h3>

        <p>
          A multi-instance architecture was the logical choice for Satellite. This would enable two important things. First, it would isolate backend instances from each other. Second, it would put the routing and administration logic into their own components, separate from the backends. Each Satellite backend would have the same internals as a single instance. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/7_1-multi-instance-concept.svg"
            alt="Multi-instance architecture concept."
          />
        </div>

        <p>
          While this architecture addresses how to support multiple backends, it does introduce many new problems. 
        </p>

        <h3>7.2) What are the Challenges of a Multi-Instance Architecture?</h3>

        <p>
          In the single-instance version of Satellite, all three components existed on one server. They could be started up as a unit using Docker Compose. Docker's bridge network connected the Dgraph, Express, and Nginx containers to each other. The Nginx server in each container exposed ports that were accessible from the public internet. The Express API exposed ports that were accessible outside of the bridge network on a private network.
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/7_2-single-instance-ref.svg"
            alt="Single Satellite instance for reference."
          />
        </div>

        <p>
          At a high level, it seemed like creating a multi-instance architecture could be just a matter of starting up multiple Docker Compose files. This kind of multi-instance architecture might look like this:
        </p>
          
        <div class="img-wrapper">
          <img
            src="images/diagrams/7_2-naive-multi-instance.svg"
            alt="High-level idea of what a multi-instance architecture could be."
          />
        </div>

        <p>
          This seemed like an easy solution to an apparently simple problem. However, an architecture like this has one critical limitation. One server can only host so many Satellite backends before performance degrades or the system crashes. 
        </p>

        <h3>7.3) Scaling Satellite</h3>

        <p>
          To accommodate increasing loads on the system, we could have Satellite scale vertically or horizontally. Vertical scaling requires physically upgrading the host system. That didn't seem practical since we wanted to keep Satellite easy to use. Also, the cost of scaling vertically tends to increase exponentially as more power is needed. There is also a practical limit on how much processing power a single server can have [<a href="#footnote-22">22</a>].
        </p>

        <p>
          Horizontal scaling was a better solution for Satellite. It involves replicating and distributing the components of an application across multiple servers. This allows each server to be economically sized and allows unlimited scalability. But, it complicates communication and routing since backends can live on different host machines. Having several backends spread across multiple host machines could look like this:
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/7_3-naive-horizontal-scaling.svg"
            alt="Horizontal scaling in an inefficient way."
          />
        </div>

        <p>
          As we can see, with horizontal scaling we had another issue. Randomly distributing the backends might not make the best use of server resources. Instead, the components of a Satellite instance could be deployed onto whichever host machine is the least used. This way, we would save resources and improve performance. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/7_4-k8s-distributed-containers.svg"
            alt="A more efficient way to scale horizontally."
          />
        </div>

        <p>
          We now had a strategy for scaling Satellite to accommodate any number of individual backends. We still had several challenges to overcome to complete the multi-instance design, including: 

          <ul>
            <li>How do we make it easy for a developer to spin up and tear down Satellite backends?</li>

            <li>How do we manage communication between the components within a backend?</li>

            <li>How do we route requests from the internet to the correct backend?</li>

            <li>How do we make it easy for a developer to perform administrative tasks when they are dealing with multiple backends? </li>
          </ul>
        </p>

        <h3>7.4) Spinning Up and Tearing Down Satellite Instances</h3>

        <p>
          To spin up and tear down any number of containerized Satellite backends, we needed a tool to manage them. 
        </p>

        <p>
          For this, we used a container orchestrator. A container orchestrator is a tool to manage, scale, and maintain containerized applications. It also manages the networks that they use to communicate. We chose Kubernetes for Satellite since it's very popular and all major cloud providers support it. 
        </p>

        <p>
          Earlier, we described how Docker Compose uses a YAML file to define and configure an application composed of containers. We showed how to use it to define a single Satellite instance. 
        </p>

        <p>
          Kubernetes works in an analogous way. It lets developers define one or more containerized applications in a manifest file. A manifest file is can be written in YAML or JSON. The manifest file describes the list of components to be deployed, how they're coordinated, and their ideal state. Kubernetes works to maintain that desired state after the manifest is run and the components have been deployed. While Docker Compose makes it easy to start a single application made of containers, Kubernetes makes it easy to start any number of those applications. 
        </p>

        <p>
          Kubernetes also provides a CLI for managing deployments of containerized applications. Passing the manifest file as an argument to the Kubernetes CLI allows us to spin up and tear down Satellite backends: 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/7_4-k8s-manifest-to-instance.png"
            alt="Creating a Satellite backend from the manifest file."
          />
        </div>

        <p>
          The components of the deployed Satellite backend are spread across the Kubernetes cluster. The cluster is a group of connected nodes. The nodes are machines, virtual or physical, and a node can either be a master or worker. The nodes contain the application containers. Kubernetes distributes the components of an application in the most efficient way possible. This means that the components of any one Satellite backend might live on the same node or be spread across multiple nodes: 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/7_4-k8s-distributed-containers.svg"
            alt="Kubernetes distributing containers across nodes."
          />
        </div>

        <p>
          Distributing components like this ensures that the resources of each node are used efficiently. It does complicate communication between the components of each backend, though.
        </p>

        <h3>7.5) Managing Satellite Instance Component Communication</h3>

        <p>
          To explain how we managed component communication within Satellite backends, first we need to describe a little bit of how Kubernetes handles things internally.
        </p>

        <p>
          Kubernetes places containers onto pods. A pod is a Kubernetes object that runs a group of one or more containers. You can imagine a pod as a wrapper around one or more Docker containers. It allows Kubernetes to manage the lifecycle of the containers running inside the pod. In a single Satellite backend, each container (Nginx, Dgraph, and Express API) runs as separate pods: 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/7_5-k8s-pods.svg"
            alt="Kubernetes pods on a node."
          />
        </div>

        <p>
          Each pod has its own IP address that lets it be discovered within a cluster:
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/7_5-k8s-pod-to-pod-direct.svg"
            alt="Kubernetes communication between pods."
          />
        </div>

        <p>
          If a pod crashes, Kubernetes will make sure that a new pod is deployed to take its place. This new pod will have a different IP address, though. This means that we could not hard-code the IP addresses of separate components: 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/7_5-k8s-pod-to-pod-fail.svg"
            alt="Kubernetes communication between pods not working."
          />
        </div>

        <p>
          Another option for pod-to-pod communication is to use Kubernetes' built-in services. We used one here called ClusterIP. It provides a fixed, defined gateway to a pod. A ClusterIP service proxies requests to a set of other pods according to its configuration in a manifest file. 
        </p>

        <p>
          To ensure reliable component communication in a Satellite backend, we used Kubernetes services. The diagram below shows how this works. Here, the pod running the Express API is defined as part of the app-server service. Requests from the Nginx pod can be proxied to the Express API pod through the app-server service. The domain name in the request would be the name of the service, app-server. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/7_5-k8s-pod-comms-with-service.svg"
            alt="Communication between pods via the ClusterIP Service."
          />
        </div>

        <p>
          We now had a way for components to communicate with other components within the Kubernetes cluster. But we still had a critical networking challenge: how do we route requests from the internet to the correct Satellite backend? 
        </p>

        <h3>7.6) Routing Requests to Individual Satellites</h3>

        <p>
          Kubernetes automatically provisions an external load balancer for deployments. The load balancer provides an internet-accessible IP address. It forwards incoming requests to the correct ports on cluster nodes. That makes it easy to route requests to the worker nodes.   
        </p>

        <p>
          But how does the load balancer know which pods to forward requests to in the cluster? The external load balancer only forwards requests to worker nodes. This means that the worker node must have some way of forwarding an external request to a pod.
        </p>
        
        <p>
          Kubernetes' services are the answer here. Each Satellite backend needs its own load balancer service, defined on the worker nodes, that is configured to forward to it. The load balancer service for a backend is used by both the external load balancer and worker nodes to forward requests to the correct set of pods.
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/7_5-k8s-single-load-balancer.svg"
            alt="External communication using a single load balancer."
          />
        </div>

        <p>
          There is a problem with this approach, though. This method of forwarding external requests works well with only a few Satellite backends. But once we have many backends, this method grows unwieldy. The reason for this is two-fold. Not only does each backend need its own load balancer service, but each load balancer service needs its own dedicated external load balancer. Having an external load balancer for each Satellite instance would quickly become resource-intensive. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/7_5-k8s-many-load-balancers.svg"
            alt="External communication when there are many load balancers."
          />
        </div>

        <p>
          At this point, our ideal setup was to have one external load balancer to forward external requests to a single load balancer service. The single load balancer service would be configured to send requests to the correct backends. 
        </p>

        <p>
          To do this, we used Traefik. Traefik is a reverse proxy that can forward requests based on a set of user-defined routing rules. We deployed Traefik as a pod within the cluster. This let Traefik use the ClusterIP services to forward requests to the correct pods. 
        </p>

        <p>
          In a Satellite deployment, the external load balancer receives requests and forwards them to the single load balancer service. The load balancer service then forwards requests to Traefik. Traefik routes requests to the correct Satellite backend and pod using the request's subdomain, domain, and path.
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/7_5-k8s-traefik.svg"
            alt="External communication using Traefik."
          />
        </div>

        <p>
          In this setup, the hostname of each Satellite backend is dynamically generated. Having to request SSL certificates manually would be cumbersome and tricky. A benefit of using Traefik is that it requests SSL certificates for subdomains automatically. This lets Satellite use HTTPS by default for every new backend. This creates a slight delay when spinning up a new Satellite, though.
        </p>

        <p>
          At this point, we had all the functionality for the multi-instance architecture built. The final step was to provide some easy way for a developer to interact with it. 
        </p>

        <h3>7.7) Admin Panel</h3>

        <p>
          Our multi-instance came with the cost of extra application layers for container orchestration and networking.
        </p>

        <p>
          To keep these layers simple to interact with, we needed one more thing: an intuitive GUI. That would let a developer spin up, tear down, or manage their Satellite backends. 
        </p>

        <h4>7.7.1) Satellite Backend Lifecycle Management</h4>

        <p>
          The first step in building an admin panel was allowing users of a Satellite deployment to register and authenticate at 'admin.domain.com'. Once authenticated, a frontend developer would be authorized to manage their backend. Upon sign in, frontend developers are presented with a UI that allows them to spin up a new backend by specifying a name. They can also tear down a backend from the admin panel with the click of a button. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/gifs/spin-up-satellite.gif"
            alt="Spinning up a new Satellite instance."
          />
        </div>

        <div class="img-wrapper">
          <img
            src="images/gifs/destroy-satellite.gif"
            alt="Destroying a satellite instance."
          />
        </div>

        <p>
          Using a container orchestrator made it easy to spin up and tear down Satellite backends. We could do this by passing a manifest file for each backend to the Kubernetes CLI. This would, though, require root access to the master node running Satellite. This would introduce security concerns and was not the kind of interface we could expose to frontend developers.  
        </p>

        <p>
          An Nginx container running in the cluster serves the admin panel as static files. A containerized Express app handles requests to manage backends. Lastly, a container running Postgres manages user accounts and the backends they've created. 
        </p>

        <p>
          Now we had a GUI for Satellite backends to be spun up and torn down. Next, we needed an easy way for developers to manage the GraphQL schema of each backend. 
        </p>

        <h4>7.7.2) Schema Management</h4>

        <p>
          One of the benefits of using Dgraph is the ability to easily update its GraphQL schema. We built a schema viewer into the admin panel to see Dgraph's schema. It uses Codemirror to provide GraphQL syntax highlighting.  
        </p>

        <div class="img-wrapper">
          <img
            src="images/diagrams/7_7_2-code-mirror.png"
            alt="Viewing a GraphQL schema using Codemirror."
          />
        </div>

        <p>
          Uploading new schema is done by uploading a schema file in the admin panel. It's sent in a POST request to the admin backend. The admin backend extracts the backend ID and uses it to proxy the request to the correct Satellite backend. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/gifs/add-schema.gif"
            alt="Uploading a GraphQL schema."
          />
        </div>

        <p>
          Uploading the GraphQL schema is one thing, but we also wanted it to be easy to explore the resulting GraphQL API. We wanted the rich client-side experience that is part of what makes GraphQL so popular. 
        </p>

        <h4>7.6.3) Schema Exploration</h4>

        <p>
          GraphQL gives developers the ability to introspect their schema and even make queries and mutations against it. We wanted to let frontend developers do this within the admin panel.  They should be able to test their schema, make queries against it, and even populate the Dgraph instance with data to power their application. 
        </p>

        <p>
          To do this, we used GraphiQL. GraphiQL is an IDE for GraphQL and makes it easy for frontend developers to test and explore their GraphQL schema. To make this work, we needed to make a query to the /graphql endpoint of the currently selected Satellite. This endpoint allows us to make an introspection query to populate the GraphiQL IDE. Our admin panel makes a POST request with the current backend ID to the admin backend, which proxies the request to the correct backend. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/gifs/add-data.gif"
            alt="Exploring a schema with GraphiQl."
          />
        </div>

        <h4>7.7.4) Static File Hosting</h4>

        <p>
          We wanted to give frontend developers a convenient way to host their frontend static files. A single Satellite backend already had this feature, so the challenge became how to proxy the request to the correct backend. 
        </p>

        <p>
          To do this, we refactored the Nginx container in a single backend to accept a .zip file for frontend hosting. All other files can be uploaded as non .zip files. If a .zip file is uploaded, the previous static files served by Nginx are replaced. 
        </p>

        <div class="img-wrapper">
          <img
            src="images/gifs/add-zip.gif"
            alt="Adding a zip file for static file hosting."
          />
        </div>

        <p>
          When a frontend developer uploads a file, a POST request is made. It includes the file as the request body and the backend ID as a part of the request path. The admin backend then proxies the request to the correct Satellite backend.
        </p>

        <p>
          With the admin panel complete, we had a simple, intuitive interface. This brought us to the conclusion of Satellite's design. We now had a GraphQL Backend-as-a-Service, easy to use and deploy, that could support any number of GraphQL backends!
        </p>

        <section id="footnotes">
          <h2 id="references">8) References</h2>

          <ol>
            <li id="footnote-1">
              <a
                href="https://blog.csssr.com/en/article/split-stack-web-development"
                target="_blank"
                >https://blog.csssr.com/en/article/split-stack-web-development</a
              >
            </li>

            <li id="footnote-2">
              Ejsmont, Artur. Web Scalability for Startup Engineers: Tips &
              Techniques for Scaling Your Web Application. McGraw-Hill
              Education, 2015.
            </li>

            <li id="footnote-3">
              <a
                href="https://www.youtube.com/watch?v=783ccP__No8"
                target="_blank"
                >GraphQL: The Documentary -
                https://www.youtube.com/watch?v=783ccP__No8</a
              >
            </li>

            <li id="footnote-4">
              Mukhiya, Suresh & Rabbi, Fazle & Pun, Ka I Violet & Rutle, Adrian
              & Lamo, Yngve. (2019). A GraphQL approach to Healthcare
              Information Exchange with HL7 FHIR. Procedia Computer Science.
              160. 338-345. 10.1016/j.procs.2019.11.082.
            </li>

            <li id="footnote-5">
              <a href="https://www.graphql.com/case-studies/" target="_blank"
                >https://www.graphql.com/case-studies/</a
              >
            </li>

            <li id="footnote-6">
              <a href="http://spec.graphql.org/draft/" target="_blank"
                >http://spec.graphql.org/draft/</a
              >
            </li>

            <li id="footnote-7">
              <a
                href="https://www.ibm.com/cloud/learn/three-tier-architecture"
                target="_blank"
                >https://www.ibm.com/cloud/learn/three-tier-architecture</a
              >
            </li>

            <li id="footnote-8">
              Lauret, A. (2019). The Design of Web APIs. Shelter Island, NY:
              Manning Publications.
            </li>

            <li id="footnote-9">
              <a
                href="https://medium.com/paypal-engineering/scaling-graphql-at-paypal-b5b5ac098810"
                target="_blank"
                >https://medium.com/paypal-engineering/scaling-graphql-at-paypal-b5b5ac098810</a
              >
            </li>

            <li id="footnote-10">
              <a
                href="https://fullstackopen.com/en/part8/graph_ql_server"
                target="_blank"
                >https://fullstackopen.com/en/part8/graph_ql_server</a
              >
            </li>

            <li id="footnote-11">
              <a
                href="https://helda.helsinki.fi/handle/10138/304677"
                target="_blank"
                >https://helda.helsinki.fi/handle/10138/304677</a
              >
            </li>

            <li id="footnote-12">
              <a
                href="https://www.apollographql.com/docs/tutorial/resolvers/"
                target="_blank"
                >https://www.apollographql.com/docs/tutorial/resolvers/</a
              >
            </li>

            <li id="footnote-13">
              <a
                href="https://www.cloudflare.com/learning/serverless/glossary/backend-as-a-service-baas/"
                target="_blank"
                >https://www.cloudflare.com/learning/serverless/glossary/backend-as-a-service-baas/</a
              >
            </li>

            <li id="footnote-14">
              <a
                href="https://www.infoworld.com/article/2640739/rest-and-crud--the-impedance-mismatch.html"
                target="_blank"
                >https://www.infoworld.com/article/2640739/rest-and-crud--the-impedance-mismatch.html</a
              >
            </li>

            <li id="footnote-15">
              <a
                href="https://www.graphql-tools.com/docs/resolvers/"
                target="_blank"
                >https://www.graphql-tools.com/docs/resolvers/</a
              >
            </li>

            <li id="footnote-16">
              <a
                href="https://neo4j.com/developer/graph-database/"
                target="_blank"
                >https://neo4j.com/developer/graph-database/</a
              >
            </li>

            <li id="footnote-17">
              <a
                href="https://db-engines.com/en/ranking/graph+dbms"
                target="_blank"
                >https://db-engines.com/en/ranking/graph+dbms</a
              >
            </li>

            <li id="footnote-18">
              <a
                href="https://www.nginx.com/resources/glossary/nginx/"
                target="_blank"
                >https://www.nginx.com/resources/glossary/nginx/</a
              >
            </li>

            <li id="footnote-19">
              <a href="https://cloud.google.com/containers" target="_blank"
                >https://cloud.google.com/containers</a
              >
            </li>

            <li id="footnote-20">
              <a
                href="https://www.backblaze.com/blog/vm-vs-containers/"
                target="_blank"
                >https://www.backblaze.com/blog/vm-vs-containers/</a
              >
            </li>

            <li id="footnote-21">
              <a
                href="https://dltj.org/article/software-development-practice/"
                target="_blank"
                >https://dltj.org/article/software-development-practice/</a
              >
            </li>

            <li id="footnote-22">
              Kleppmann, Martin. Designing Data-Intensive Applications: The Big Ideas behind Reliable, Scalable, and Maintainable Systems. First edition, O’Reilly Media, 2017.
            </li>

          </ol>
        </section>
      </section>
    </main>

    <section id="our-team">
      <h1>Our Team</h1>

      <p>
        We are looking for opportunities. If you liked what you saw and want to
        talk more, please reach out!
      </p>

      <ul>
        <li class="individual">
          <img src="images/avatars/will-profile.jpg" alt="Will Baker" />

          <h3>Will Baker</h3>

          <p>Cleveland, OH</p>

          <ul class="social-icons">
            <li>
              <a href="mailto:wbaker@gmail.com" target="">
                <img src="images/icons/email_icon.png" alt="email" />
              </a>
            </li>

            <li>
              <a href="https://willbaker.dev/" target="_blank">
                <img src="images/icons/website_icon.png" alt="website" />
              </a>
            </li>

            <li>
              <a
                href="https://www.linkedin.com/in/william-baker-8598779b/"
                target="_blank"
              >
                <img src="images/icons/linked_in_icon.png" alt="linkedin" />
              </a>
            </li>
          </ul>
        </li>

        <li class="individual">
          <img src="images/avatars/ilyas.jpeg" alt="Ilyas Kussainov" />

          <h3>Ilyas Kussainov</h3>

          <p>Anytown, CA</p>

          <ul class="social-icons">
            <li>
              <a href="mailto:wgatever@gmail.com" target="">
                <img src="images/icons/email_icon.png" alt="email" />
              </a>
            </li>

            <li>
              <a href="https://www.google.com/" target="_blank">
                <img src="images/icons/website_icon.png" alt="website" />
              </a>
            </li>

            <li>
              <a href="https://www.linkedin.com/in/somebody/" target="_blank">
                <img src="images/icons/linked_in_icon.png" alt="linkedin" />
              </a>
            </li>
          </ul>
        </li>

        <li class="individual">
          <img src="images/avatars/jordan-profile.jpg" alt="Jordan Moore" />

          <h3>Jordan Moore</h3>

          <p>Croton on Hudson, NY</p>

          <ul class="social-icons">
            <li>
              <a href="mailto:jordanmoore753@gmail.com" target="">
                <img src="images/icons/email_icon.png" alt="email" />
              </a>
            </li>

            <li>
              <a href="https://jordanmoore.dev/" target="_blank">
                <img src="images/icons/website_icon.png" alt="website" />
              </a>
            </li>

            <li>
              <a
                href="https://www.linkedin.com/in/jordan-moore-41ba011a3/"
                target="_blank"
              >
                <img src="images/icons/linked_in_icon.png" alt="linkedin" />
              </a>
            </li>
          </ul>
        </li>

        <li class="individual">
          <img src="images/avatars/lewis_profile.jpeg" alt="Lewis Reynolds" />

          <h3>Lewis Reynolds</h3>

          <p>Anytown, USA</p>

          <ul class="social-icons">
            <li>
              <a href="mailto:wgatever@gmail.com" target="">
                <img src="images/icons/email_icon.png" alt="email" />
              </a>
            </li>

            <li>
              <a href="https://www.google.com/" target="_blank">
                <img src="images/icons/website_icon.png" alt="website" />
              </a>
            </li>

            <li>
              <a href="https://www.linkedin.com/in/somebody/" target="_blank">
                <img src="images/icons/linked_in_icon.png" alt="linkedin" />
              </a>
            </li>
          </ul>
        </li>
      </ul>
    </section>
  </body>
</html>
